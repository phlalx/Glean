"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[698],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return m},MDXProvider:function(){return p},mdx:function(){return f},useMDXComponents:function(){return d},withMDXComponents:function(){return c}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},i.apply(this,arguments)}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var m=a.createContext({}),c=function(e){return function(n){var t=d(n.components);return a.createElement(e,i({},n,{components:t}))}},d=function(e){var n=a.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(m.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=d(t),p=r,u=c["".concat(l,".").concat(p)]||c[p]||h[p]||i;return t?a.createElement(u,o(o({ref:n},m),{},{components:t})):a.createElement(u,o({ref:n},m))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var m=2;m<i;m++)l[m]=t[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},12038:function(e,n,t){t.d(n,{EO:function(){return o},O1:function(){return l},Rr:function(){return s}});var a,r=t(67294),i=t(44256);function l(e){return r.createElement("a",{href:a+e.file},e.file)}function o(e){return r.createElement("a",{href:a+e.file},e.children)}a=(0,i.isInternal)()?"https://www.internalfb.com/code/fbsource/fbcode/":"https://github.com/facebookincubator/Glean/tree/master/";var s=function(e){e.children;var n=e.internal,t=e.external;return(0,i.fbContent)({internal:r.createElement("code",null,n),external:r.createElement("code",null,t)})}},52638:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return m},metadata:function(){return d},toc:function(){return p}});var a=t(87462),r=t(63366),i=(t(67294),t(3905)),l=t(44256),o=t(12038),s=["components"],m={id:"all",title:'The special "all" schema',sidebar_label:'The special "all" schema'},c=void 0,d={unversionedId:"schema/all",id:"schema/all",isDocsHomePage:!1,title:'The special "all" schema',description:"There is a special schema known as the all schema, defined in .",source:"@site/docs/schema/all.md",sourceDirName:"schema",slug:"/schema/all",permalink:"/docs/schema/all",editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/schema/all.md",tags:[],version:"current",frontMatter:{id:"all",title:'The special "all" schema',sidebar_label:'The special "all" schema'},sidebar:"someSidebar",previous:{title:"Changing a schema",permalink:"/docs/schema/changing"},next:{title:"Workflow",permalink:"/docs/schema/workflow"}},p=[{value:"Multiple versions of <code>all</code>",id:"multiple-versions-of-all",children:[],level:2}],h={toc:p};function u(e){var n=e.components,t=(0,r.Z)(e,s);return(0,i.mdx)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)(l.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,i.mdx)("p",null,"There is a special schema known as the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema, defined in ",(0,i.mdx)(o.O1,{file:"glean/schema/source/facebook/schema.angle",mdxType:"SrcFile"}),".")),(0,i.mdx)(l.OssOnly,{mdxType:"OssOnly"},(0,i.mdx)("p",null,"There is a special schema known as the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema, defined in ",(0,i.mdx)(o.O1,{file:"glean/schema/source/schema.angle",mdxType:"SrcFile"}),".")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema is used to resolve names to particular predicates and\ntypes when the version in omitted. This matters in a few places:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"When Thrift types are generated from the schema, the types and\npredicates from the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema determine which names are\nunversioned in the generated Thrift. For example, if the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all"),"\nschema contains ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.1"),", then the predicate ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.File.1")," will be\nsimply called ",(0,i.mdx)("inlineCode",{parentName:"p"},"File")," in the generated Thrift; otherwise it would be\ncalled ",(0,i.mdx)("inlineCode",{parentName:"p"},"File_1"),".")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"When an ",(0,i.mdx)("a",{parentName:"p",href:"../../angle/intro"},"Angle query")," mentions an unversioned predicate or type, the\nname is resolved to a particular version of that predicate or type\nusing the current ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"When deriving a predicate with the CLI tool, like ",(0,i.mdx)("inlineCode",{parentName:"p"},"glean derive\npython.TargetUses"),"."))),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema is defined like this:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"schema all.6 :\n  src.1,\n  python.3,\n  code.18\n")),(0,i.mdx)("h2",{id:"multiple-versions-of-all"},"Multiple versions of ",(0,i.mdx)("inlineCode",{parentName:"h2"},"all")),(0,i.mdx)("p",null,"If you had to bump a schema version because you modified it, then you\ncan often just bump the schema version in the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema too,\nwithout creating a new version of ",(0,i.mdx)("inlineCode",{parentName:"p"},"all"),"."),(0,i.mdx)("p",null,"The exception to this is when you have clients that are using\nraw Angle queries without versions. Imagine you have:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"schema src.1 {\n   predicate File {\n     path : string\n   }\n}\n")),(0,i.mdx)("p",null,"and you add"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"schema src.2 {\n   predicate File {\n     path : string,\n     is_generated: bool\n   }\n}\n\nschema src.2 evolves src.1\n")),(0,i.mdx)("p",null,"and we update ",(0,i.mdx)("inlineCode",{parentName:"p"},"all"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"schema all.6 :\n  src.2,\n  ...\n")),(0,i.mdx)("p",null,"Now, a client that makes a query like ",(0,i.mdx)("inlineCode",{parentName:"p"},'src.File { path = "X" }')," on an\nold database with the ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.File.1")," facts will get no results, because\n",(0,i.mdx)("inlineCode",{parentName:"p"},"src.File")," is resolved to ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.File.2")," by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," schema."),(0,i.mdx)("p",null,"Note that versioned clients--those clients using a query API that\nautomatically adds versions, like the Haskell DSL--can avoid this\nproblem. Clients that are already deployed when the change is made\nwill continue to work on both the old DBs and the new DBs, thanks to\nthe ",(0,i.mdx)("inlineCode",{parentName:"p"},"evolves")," declaration. However, after recompiling the client\nagainst the new schema, the new client will only work with the new\nDBs. So be careful to deploy the new DBs before recompiling and\ndeploying the new clients."),(0,i.mdx)("p",null,"Back to the problem of unversioned clients. To ensure that these\nclients can continue to work after we've added ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.2")," and started to\ncreate DBs that contain it, we need to first make a new version of\n",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," that contains ",(0,i.mdx)("inlineCode",{parentName:"p"},"src.2"),". Keep the original version of ",(0,i.mdx)("inlineCode",{parentName:"p"},"all"),", like\nthis:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"schema all.6 :\n  src.1,\n  ...\n\nschema all.7 :\n  src.2,\n  ...\n")),(0,i.mdx)("p",null,"Next, ensure that queries are resolved by the appropriate version of\n",(0,i.mdx)("inlineCode",{parentName:"p"},"all"),": the old one for old DBs, and the new one for new DBs. We do\nthat by setting the ",(0,i.mdx)("inlineCode",{parentName:"p"},"glean.schema_version")," property in the DB when it\nis created. Setting the property can be done with the CLI tool:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"glean set-property --repo <name>/<hash> glean.schema_version=7\n")),(0,i.mdx)("p",null,"or it can be done via the API when creating a DB programmatically."),(0,i.mdx)("p",null,"To be precise, the version of ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," used to resolve a name is chosen\nas follows:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"For generating the Thrift definitions from the schema, it is the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"--version")," flag to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"gen-schema")," tool.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"For an Angle query, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"all")," version is chosen, in order of\npriority, by:"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"the optional ",(0,i.mdx)("inlineCode",{parentName:"li"},"schema_version")," field in the ",(0,i.mdx)("inlineCode",{parentName:"li"},"UserQuery")," struct from\nthe query request itself; or"),(0,i.mdx)("li",{parentName:"ul"},"the ",(0,i.mdx)("inlineCode",{parentName:"li"},"--schema-version")," flag to the server; or"),(0,i.mdx)("li",{parentName:"ul"},"the ",(0,i.mdx)("inlineCode",{parentName:"li"},"glean.schema_version")," property in the database being\nqueried.")))),(0,i.mdx)("p",null,"When creating a database, it's recommended to set the\n",(0,i.mdx)("inlineCode",{parentName:"p"},"glean.schema_version")," property to the version of the schema\ncorresponding to the data being stored, so that clients using\nunversioned queries will automatically resolve to the right versions."))}u.isMDXComponent=!0}}]);