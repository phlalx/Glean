"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[128],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return h},useMDXComponents:function(){return d},withMDXComponents:function(){return u}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},o.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),u=function(e){return function(n){var t=d(n.components);return r.createElement(e,o({},n,{components:t}))}},d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(t),m=a,f=u["".concat(i,".").concat(m)]||u[m]||p[m]||o;return t?r.createElement(f,l(l({ref:n},c),{},{components:t})):r.createElement(f,l({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},12038:function(e,n,t){t.d(n,{EO:function(){return l},O1:function(){return i},Rr:function(){return s}});var r,a=t(67294),o=t(44256);function i(e){return a.createElement("a",{href:r+e.file},e.file)}function l(e){return a.createElement("a",{href:r+e.file},e.children)}r=(0,o.isInternal)()?"https://www.internalfb.com/code/fbsource/fbcode/":"https://github.com/facebookincubator/Glean/tree/master/";var s=function(e){e.children;var n=e.internal,t=e.external;return(0,o.fbContent)({internal:a.createElement("code",null,n),external:a.createElement("code",null,t)})}},88495:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var r=t(87462),a=t(63366),o=(t(67294),t(3905)),i=(t(44256),t(12038)),l=["components"],s={id:"introduction",title:"Introduction",sidebar_label:"Introduction"},c=void 0,u={unversionedId:"introduction",id:"introduction",isDocsHomePage:!1,title:"Introduction",description:"Glean is a system for working with facts about source code. It is",source:"@site/docs/introduction.md",sourceDirName:".",slug:"/introduction",permalink:"/docs/introduction",editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/introduction.md",tags:[],version:"current",frontMatter:{id:"introduction",title:"Introduction",sidebar_label:"Introduction"},sidebar:"someSidebar",next:{title:"Trying Glean",permalink:"/docs/trying"}},d=[{value:"Components",id:"components",children:[],level:2}],m={toc:d};function p(e){var n=e.components,t=(0,a.Z)(e,l);return(0,o.mdx)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Glean is a system for working with facts about source code. It is\ndesigned for collecting and storing detailed information about code\nstructure, and providing access to the data to power tools and\nexperiences from online IDE features to offline code analysis."),(0,o.mdx)("p",null,"For example, Glean could answer all the questions you'd expect your\nIDE to answer, accurately and efficiently on a large-scale\ncodebase. Things like:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("em",{parentName:"li"},"Where is the definition of this method?")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("em",{parentName:"li"},"Where are all the callers of this function?")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("em",{parentName:"li"},"Who inherits from this class?")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("em",{parentName:"li"},"What are all the declarations in this file?"))),(0,o.mdx)("p",null,"But Glean isn't limited to storing particular kinds of data, or\nanswering particular queries. Glean comes with indexers and schemas\nfor some languages which support queries like the examples above, but\nyou can also define your own schemas and store whatever data you like,\nperhaps augmenting the data that existing indexers collect.  So, for\nexample, you could store test coverage data or profiling data."),(0,o.mdx)("p",null,"Glean's powerful query language means that you can build tools around\ncomplex queries of the underlying data. For example, you could search\nfor dead code, write code linters, API migration tools or refactoring\ntools, all by using Glean queries instead of a compiler API to inspect\nthe code structure."),(0,o.mdx)("h2",{id:"components"},"Components"),(0,o.mdx)("p",null,"Glean consists of the following:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"An ",(0,o.mdx)("strong",{parentName:"p"},"efficient storage backend")," built on\n",(0,o.mdx)("a",{parentName:"p",href:"https://rocksdb.org/"},"RocksDB"),", for storing facts. Facts are\nimmutable terms described by user-defined schemas, and form a\nDAG. Facts are automatically de-duplicated by the storage\nbackend. Think of it as being able to store and query the AST of\nyour code, efficiently and with full type-safety",(0,o.mdx)("sup",{parentName:"p",id:"fnref-1"},(0,o.mdx)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"A query engine implementing our ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("a",{parentName:"strong",href:"/docs/angle/intro"},"declarative query language\nAngle")),".  Angle is a logic language with similarities\nto Datalog, but with extensions that make it suitable for building\ncomplex queries over Glean data",(0,o.mdx)("sup",{parentName:"p",id:"fnref-2"},(0,o.mdx)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),".  Like in Datalog, Glean can\nderive new facts automatically by ",(0,o.mdx)("a",{parentName:"p",href:"/docs/derived"},"defining rules")," using\nAngle.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"A ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("a",{parentName:"strong",href:"/docs/server"},"server"))," that manages multiple databases on disk, and\nserves requests from clients to create, write, and query\ndatabases. The server currently uses Thrift, but there's no reason\nthere couldn't also be servers exposing other protocols in the\nfuture.  The server is designed to be deployed at scale, serving\nreplicated databases to large numbers of clients.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"An ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("a",{parentName:"strong",href:"/docs/shell"},"interactive shell"))," where you can type queries and explore\nthe data.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"A ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("a",{parentName:"strong",href:"/docs/cli"},"command-line tool"))," for creating, writing, and querying\ndatabases, either directly or by connecting to the server.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},"Several ",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)(i.EO,{file:"glean/schema/source",mdxType:"SrcFileLink"},"example schemas"))," for common programming languages, and\n",(0,o.mdx)("strong",{parentName:"p"},(0,o.mdx)("a",{parentName:"strong",href:"/docs/indexer/intro"},"indexers"))," for some of those.  Note that Glean\ndoesn't force all the data into a single schema; there can be\narbitrary amounts of language-specific detail in the schema for each\nlanguage. Language-neutral abstractions can be built by ",(0,o.mdx)(i.EO,{file:"glean/schema/source/codemarkup.angle",mdxType:"SrcFileLink"},"deriving facts using Angle"),"."))),(0,o.mdx)("div",{className:"footnotes"},(0,o.mdx)("hr",{parentName:"div"}),(0,o.mdx)("ol",{parentName:"div"},(0,o.mdx)("li",{parentName:"ol",id:"fn-1"},"while we could in principle store the full AST, for efficiency\nreasons we typically store only the parts we need for the clients we\nwant to support. Usually that means things like the locations of\ndefinitions and cross-references, but not expressions.",(0,o.mdx)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,o.mdx)("li",{parentName:"ol",id:"fn-2"},"If you're familiar with Datalog, it's worth noting that\ncurrently Angle is limited to non-recursive queries only.",(0,o.mdx)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}p.isMDXComponent=!0}}]);