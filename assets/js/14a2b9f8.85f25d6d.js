"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[675],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return u},MDXProvider:function(){return d},mdx:function(){return b},useMDXComponents:function(){return m},withMDXComponents:function(){return l}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},o.apply(this,arguments)}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){return function(t){var n=m(t.components);return r.createElement(e,o({},t,{components:n}))}},m=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=m(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),l=m(n),d=a,f=l["".concat(c,".").concat(d)]||l[d]||p[d]||o;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=f;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var u=2;u<o;u++)c[u]=n[u];return r.createElement.apply(null,c)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},67684:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return l}});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),c=(n(44256),["components"]),i={id:"recursion",title:"Recursion",sidebar_label:"Recursion"},s=void 0,u={unversionedId:"schema/recursion",id:"schema/recursion",isDocsHomePage:!1,title:"Recursion",description:"Predicates can be (mutually) recursive. In other words, **we can use",source:"@site/docs/schema/recursion.md",sourceDirName:"schema",slug:"/schema/recursion",permalink:"/docs/schema/recursion",editUrl:"https://github.com/facebookincubator/Glean/tree/main/glean/website/docs/schema/recursion.md",tags:[],version:"current",frontMatter:{id:"recursion",title:"Recursion",sidebar_label:"Recursion"},sidebar:"someSidebar",previous:{title:"Syntax",permalink:"/docs/schema/syntax"},next:{title:"Changing a schema",permalink:"/docs/schema/changing"}},l=[],m={toc:l};function d(e){var t=e.components,n=(0,a.Z)(e,c);return(0,o.mdx)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Predicates can be (mutually) recursive. In other words, ",(0,o.mdx)("strong",{parentName:"p"},"we can use\npredicates to define recursive types"),". You can define linked lists,\ntrees and DAGs using predicates. However, the ",(0,o.mdx)("strong",{parentName:"p"},"facts cannot form a\ncycle"),": we cannot have a circular list, or a cyclic graph in the\ndata."),(0,o.mdx)("p",null,"The restriction on cyclic data is enforced when facts are added to a\ndatabase: each new fact added to the database can only refer to\nearlier facts via its key. This is because facts are added to the\ndatabase in batches, removing duplicates and substituting references\nto duplicated facts at the same time. Allowing recursion between the\nkeys would make this process significantly harder."),(0,o.mdx)("p",null,"Facts can be recursive in their ",(0,o.mdx)("em",{parentName:"p"},"values"),", but not their ",(0,o.mdx)("em",{parentName:"p"},"keys"),". A\nmutually recursive set of facts must be added to the database in a\nsingle batch, however."),(0,o.mdx)("p",null,"To summarise, recursion is"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"allowed between ",(0,o.mdx)("em",{parentName:"li"},"predicates")),(0,o.mdx)("li",{parentName:"ul"},"not allowed between ",(0,o.mdx)("em",{parentName:"li"},"keys")),(0,o.mdx)("li",{parentName:"ul"},"allowed between ",(0,o.mdx)("em",{parentName:"li"},"values"))))}d.isMDXComponent=!0}}]);